Brian Tracy
AP Computer Science
Kuszmaul

Reading from Book up to 1.3

This reading discusses the differences between iterative and recursive methods to implementing an algoritm. The two algorithms looked at are taking the factorial of a given number and calculating the fibonacci sequence. 

In the first example, factorial, the author chooses to implement a recursive algorithm. By showing the call stack created by this algorithm, we get to see the "shape" of the algorithm as it executes. This "shape" is typical of recursion, it first expands as the function calls build up, then shrinks as they all boil down to thier final results. This is not how an iterative implementation would look. An iterative shape of the same algorithm has no build up or shrink, it is linear. This linear shape is more compact than the bulge then shrink.

The author makes several points against using recursion. The first is that it is more expensive as the interpreter has to store the state of the algorithm as it executes. Also, a recursive function cannot be started at an arbitrary point in time becuase it has to know its previous state. For iterative functions, the values used in an algorithm are constantly being updated, so the present state is the only one that matters. This means that supplied the correct values, an iterative algorithm can pick up at any point. Another reason against the use of recursion is that it leads to lots of redundant computations. For example, the recursion tree generated by calculating the fifth fibonacci number leads to calculating the third fibonacci number twice. This is a massive waste of computations, but has to be done with the recursive implementation.



